name: Commit Lint

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [ main ]

jobs:
  commitlint:
    name: Lint Commit Messages
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install commitlint
      run: |
        npm install -g @commitlint/cli @commitlint/config-conventional

    - name: Create commitlint config
      run: |
        cat > .commitlintrc.js << 'EOF'
        module.exports = {
          extends: ['@commitlint/config-conventional'],
          rules: {
            'type-enum': [2, 'always', [
              'feat',
              'fix',
              'docs',
              'style',
              'refactor',
              'perf',
              'test',
              'build',
              'ci',
              'chore',
              'revert'
            ]],
            'scope-case': [2, 'always', 'lower-case'],
            'subject-case': [2, 'always', 'lower-case'],
            'subject-empty': [2, 'never'],
            'subject-full-stop': [2, 'never', '.'],
            'type-case': [2, 'always', 'lower-case'],
            'type-empty': [2, 'never'],
            'body-leading-blank': [1, 'always'],
            'footer-leading-blank': [1, 'always']
          }
        };
        EOF

    - name: Lint commits
      run: |
        # Get the base commit (where this branch diverged from main)
        base_commit=$(git merge-base HEAD origin/main)

        echo "Checking commits from $base_commit to HEAD"

        # Check each commit in the PR
        failed_commits=()
        while read -r commit; do
          if ! echo "$commit" | commitlint; then
            failed_commits+=("$commit")
          fi
        done < <(git rev-list ${base_commit}..HEAD --reverse --pretty=format:"%s" --no-merges | grep -v "^commit")

        if [ ${#failed_commits[@]} -gt 0 ]; then
          echo "âŒ The following commits don't follow conventional commit format:"
          printf '%s\n' "${failed_commits[@]}"
          echo
          echo "Please fix commit messages to follow conventional commit format:"
          echo "type(scope): description"
          echo
          echo "Valid types: feat, fix, docs, style, refactor, perf, test, build, ci, chore"
          echo "Examples:"
          echo "  feat(cli): add new command for listing entries"
          echo "  fix(export): handle empty date ranges correctly"
          echo "  docs: update README with installation instructions"
          exit 1
        else
          echo "âœ… All commits follow conventional commit format"
        fi

  suggest-conventional-commits:
    name: Suggest Conventional Commits
    runs-on: ubuntu-latest
    if: always()

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Analyze commit messages and suggest improvements
      uses: actions/github-script@v7
      with:
        script: |
          const { execSync } = require('child_process');

          try {
            // Get commits in this PR
            const baseCommit = execSync('git merge-base HEAD origin/main').toString().trim();
            const commits = execSync(`git log --format="%H|%s" ${baseCommit}..HEAD --reverse --no-merges`).toString().trim().split('\n').filter(line => line);

            let issues = [];
            let suggestions = [];

            commits.forEach(line => {
              const [hash, message] = line.split('|');
              const shortHash = hash.substring(0, 7);

              // Check if commit follows conventional format
              const conventionalRegex = /^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?: .+/;

              if (!conventionalRegex.test(message)) {
                issues.push(`- \`${shortHash}\`: "${message}"`);

                // Suggest improvements based on common patterns
                if (message.toLowerCase().includes('add') || message.toLowerCase().includes('implement')) {
                  suggestions.push(`  â†’ Consider: \`feat: ${message.toLowerCase()}\``);
                } else if (message.toLowerCase().includes('fix') || message.toLowerCase().includes('bug')) {
                  suggestions.push(`  â†’ Consider: \`fix: ${message.toLowerCase()}\``);
                } else if (message.toLowerCase().includes('update') && message.toLowerCase().includes('doc')) {
                  suggestions.push(`  â†’ Consider: \`docs: ${message.toLowerCase()}\``);
                } else if (message.toLowerCase().includes('refactor') || message.toLowerCase().includes('clean')) {
                  suggestions.push(`  â†’ Consider: \`refactor: ${message.toLowerCase()}\``);
                } else if (message.toLowerCase().includes('test')) {
                  suggestions.push(`  â†’ Consider: \`test: ${message.toLowerCase()}\``);
                } else {
                  suggestions.push(`  â†’ Consider appropriate type: \`feat/fix/docs/refactor: ${message.toLowerCase()}\``);
                }
              }
            });

            if (issues.length > 0) {
              let body = `## ðŸ“ Conventional Commit Suggestions\n\n`;
              body += `Some commits in this PR don't follow [conventional commit](https://www.conventionalcommits.org/) format:\n\n`;
              body += `### Non-conventional commits:\n${issues.join('\n')}\n\n`;
              body += `### Suggestions:\n${suggestions.join('\n')}\n\n`;
              body += `### Why conventional commits?\n`;
              body += `- ðŸ¤– **Automated versioning**: Determines if this PR triggers a release\n`;
              body += `- ðŸ“‹ **Auto-generated changelogs**: Creates meaningful release notes\n`;
              body += `- ðŸ” **Clear history**: Makes it easy to understand what changed\n\n`;
              body += `### Quick reference:\n`;
              body += `- \`feat:\` - New feature (triggers minor version bump)\n`;
              body += `- \`fix:\` - Bug fix (triggers patch version bump)\n`;
              body += `- \`docs:\` - Documentation changes (no version bump)\n`;
              body += `- \`refactor:\` - Code refactoring (no version bump)\n`;
              body += `- \`test:\` - Test changes (no version bump)\n`;
              body += `- \`chore:\` - Other maintenance (no version bump)\n\n`;
              body += `**Note**: You can fix this by rebasing and updating commit messages, or we can squash merge with a proper conventional commit message.`;

              // Check for existing comment
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });

              const existingComment = comments.find(comment =>
                comment.user.type === 'Bot' &&
                comment.body.includes('Conventional Commit Suggestions')
              );

              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: body
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: body
                });
              }
            }
          } catch (error) {
            console.log('No commits to analyze or error occurred:', error.message);
          }